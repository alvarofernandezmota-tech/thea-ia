üèÜ MILESTONE H03 ‚Äî FSM Avanzado & CoreRouter Integration
Hito: H03
Fase: 2 / 4
Per√≠odo: 2025-11-20 ~ 2025-11-25
Estado: ‚è≥ PR√ìXIMO (Listo para iniciar)
Duraci√≥n Estimada: 66h (3-4 sesiones intensivas)
Responsable: √Ålvaro Fern√°ndez Mota (CEO THEA-IA)

üéØ Objetivo
Integrar CoreRouter con TelegramAdapter, mejorar FSM Engine v2 con callbacks avanzados, implementar procesamiento NLP b√°sico para primera conversaci√≥n inteligente end-to-end.

üìä ESTADO INICIAL
‚úÖ Ventajas del Estado Actual (H02 Completado)
text
‚úÖ Database Layer 100% operativo
   - 5 Repositorios async completos
   - 65/65 tests PASSING
   - 83.5% coverage

‚úÖ TelegramAdapter funcional
   - Persistencia autom√°tica
   - Error handling
   - Comandos b√°sicos (/start, /help, /reset)

‚úÖ Primera conversaci√≥n real guardada
   - Usuario: Entu (Telegram ID: 6961767622)
   - Session: telegram_6961767622
   - Mensajes en PostgreSQL

‚úÖ Arquitectura multi-tenant
   - Isolation garantizado
   - Timezone-aware
‚Üí H03 aprovecha esta base s√≥lida para a√±adir inteligencia NLP.

üìã MICRO-RECOMPENSAS (7 Fases)
#	Fase	Horas	Tests	Prioridad	Status
1	CoreRouter.process() implementado	12h	8	‚≠ê‚≠ê‚≠ê	‚è≥
2	FSM Engine v2 (callbacks avanzados)	10h	6	‚≠ê‚≠ê‚≠ê	‚è≥
3	Intent Detector b√°sico (spaCy)	12h	10	‚≠ê‚≠ê‚≠ê	‚è≥
4	Entity Extractor b√°sico	10h	8	‚≠ê‚≠ê‚≠ê	‚è≥
5	Context Manager mejorado	8h	6	‚≠ê‚≠ê	‚è≥
6	Integration tests CoreRouter + Telegram	8h	12	‚≠ê‚≠ê‚≠ê	‚è≥
7	Primera conversaci√≥n NLP end-to-end	6h	-	‚≠ê‚≠ê‚≠ê	‚è≥
TOTAL		66h	50 tests		‚è≥
üèóÔ∏è ARQUITECTURA H03
text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Telegram User                        ‚îÇ
‚îÇ                  (Entu / Nuevos usuarios)               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ "Quiero crear evento ma√±ana 15:00"
                     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              TelegramAdapter (H02 ‚úÖ)                   ‚îÇ
‚îÇ  ‚îú‚îÄ Persistencia autom√°tica                            ‚îÇ
‚îÇ  ‚îú‚îÄ Error handling                                     ‚îÇ
‚îÇ  ‚îú‚îÄ Comandos b√°sicos                                   ‚îÇ
‚îÇ  ‚îî‚îÄ Forward a CoreRouter                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
                     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              CoreRouter (H03 üî•)                        ‚îÇ
‚îÇ  ‚îú‚îÄ 1. Preprocessing                                   ‚îÇ
‚îÇ  ‚îú‚îÄ 2. Intent Detection (spaCy)                        ‚îÇ
‚îÇ  ‚îú‚îÄ 3. Entity Extraction                               ‚îÇ
‚îÇ  ‚îú‚îÄ 4. Agent Routing                                   ‚îÇ
‚îÇ  ‚îî‚îÄ 5. Response Formatting                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ intent="create_event"
                     ‚îÇ entities={date: "ma√±ana 15:00"}
                     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              FSM Engine v2 (H03 üî•)                     ‚îÇ
‚îÇ  ‚îú‚îÄ Pre-callback (validaciones)                        ‚îÇ
‚îÇ  ‚îú‚îÄ State transition                                   ‚îÇ
‚îÇ  ‚îú‚îÄ Context merge                                      ‚îÇ
‚îÇ  ‚îú‚îÄ Post-callback (side effects)                       ‚îÇ
‚îÇ  ‚îî‚îÄ Error callback (rollback)                          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
                     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              Agent Handlers (H03 üî•)                    ‚îÇ
‚îÇ  ‚îú‚îÄ AgendaAgent (query agenda)                         ‚îÇ
‚îÇ  ‚îú‚îÄ EventsAgent (create/edit events)                   ‚îÇ
‚îÇ  ‚îú‚îÄ NotesAgent (create/search notes)                   ‚îÇ
‚îÇ  ‚îú‚îÄ QueryAgent (general queries)                       ‚îÇ
‚îÇ  ‚îî‚îÄ FallbackAgent (unknown intents)                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
                     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           Database Layer (H02 ‚úÖ)                       ‚îÇ
‚îÇ  ‚îú‚îÄ EventRepository.create()                           ‚îÇ
‚îÇ  ‚îú‚îÄ ConversationRepository.update_state()              ‚îÇ
‚îÇ  ‚îú‚îÄ MessageHistoryRepository.add_message()             ‚îÇ
‚îÇ  ‚îî‚îÄ Multi-tenant isolation                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
üì¶ DELIVERABLES DETALLADOS
üî• FASE 1: CoreRouter Implementation (12h)
Ubicaci√≥n: src/theaia/core/router.py

Objetivo: Enrutador central que procesa mensajes y coordina flujo completo.

C√≥digo Principal
python
"""
CoreRouter - Enrutador central de mensajes
Procesa mensajes entrantes y coordina pipeline completo
"""

from typing import Dict, Optional, Tuple
from dataclasses import dataclass


@dataclass
class Message:
    """Mensaje procesado."""
    text: str
    user_id: int
    tenant_id: str
    session_id: str
    timestamp: datetime


@dataclass
class ProcessedMessage:
    """Resultado del procesamiento."""
    intent: str
    entities: Dict
    confidence: float
    agent_target: str


class CoreRouter:
    """
    Enrutador central que coordina todo el flujo.
    
    Pipeline:
    1. Preprocess (limpieza, normalizaci√≥n)
    2. Intent Detection (spaCy)
    3. Entity Extraction
    4. Agent Routing
    5. Response Formatting
    """
    
    def __init__(self, intent_detector, entity_extractor):
        self.intent_detector = intent_detector
        self.entity_extractor = entity_extractor
    
    async def process(self, message: Message) -> ProcessedMessage:
        """
        Procesa mensaje completo.
        
        Args:
            message: Mensaje del usuario
            
        Returns:
            ProcessedMessage con intent, entities, agent
        """
        # 1. Preprocessing
        cleaned_text = self._preprocess(message.text)
        
        # 2. Intent Detection
        intent, confidence = await self._detect_intent(cleaned_text)
        
        # 3. Entity Extraction
        entities = await self._extract_entities(cleaned_text, intent)
        
        # 4. Agent Routing
        agent_target = self._route_to_agent(intent)
        
        return ProcessedMessage(
            intent=intent,
            entities=entities,
            confidence=confidence,
            agent_target=agent_target
        )
    
    def _preprocess(self, text: str) -> str:
        """Limpia y normaliza texto."""
        # Lowercase
        text = text.lower().strip()
        
        # Remove extra whitespace
        text = " ".join(text.split())
        
        # Remove special characters (keep Spanish)
        # Keep: √°, √©, √≠, √≥, √∫, √±, ¬ø, ¬°
        
        return text
    
    async def _detect_intent(self, text: str) -> Tuple[str, float]:
        """Detecta intent con spaCy."""
        return await self.intent_detector.detect(text)
    
    async def _extract_entities(self, text: str, intent: str) -> Dict:
        """Extrae entidades relevantes."""
        return await self.entity_extractor.extract(text, intent)
    
    def _route_to_agent(self, intent: str) -> str:
        """
        Enruta a agente correcto seg√∫n intent.
        
        Mapping:
        - create_event, edit_event, delete_event ‚Üí EventsAgent
        - create_note, search_notes ‚Üí NotesAgent
        - query_agenda, get_reminders ‚Üí AgendaAgent
        - general_query ‚Üí QueryAgent
        - unknown ‚Üí FallbackAgent
        """
        intent_to_agent = {
            "create_event": "EventsAgent",
            "edit_event": "EventsAgent",
            "delete_event": "EventsAgent",
            "create_note": "NotesAgent",
            "search_notes": "NotesAgent",
            "query_agenda": "AgendaAgent",
            "get_reminders": "AgendaAgent",
            "general_query": "QueryAgent",
            "help": "HelpAgent",
            "unknown": "FallbackAgent"
        }
        
        return intent_to_agent.get(intent, "FallbackAgent")
Tests (8 tests)
Ubicaci√≥n: src/theaia/tests/unit/core/test_router.py

python
import pytest
from src.theaia.core.router import CoreRouter, Message

class TestCoreRouter:
    """Tests para CoreRouter."""
    
    @pytest.mark.asyncio
    async def test_process_simple_message(self, router):
        """Test procesamiento mensaje simple."""
        message = Message(
            text="Hola",
            user_id=1,
            tenant_id="default",
            session_id="test_session",
            timestamp=datetime.now(timezone.utc)
        )
        
        result = await router.process(message)
        
        assert result.intent in ["help", "general_query"]
        assert result.confidence > 0.5
    
    @pytest.mark.asyncio
    async def test_detect_intent_create_event(self, router):
        """Test detecci√≥n intent crear evento."""
        message = Message(
            text="Quiero crear un evento ma√±ana a las 3pm",
            user_id=1,
            tenant_id="default",
            session_id="test_session",
            timestamp=datetime.now(timezone.utc)
        )
        
        result = await router.process(message)
        
        assert result.intent == "create_event"
        assert result.confidence > 0.8
        assert result.agent_target == "EventsAgent"
    
    @pytest.mark.asyncio
    async def test_detect_intent_create_note(self, router):
        """Test detecci√≥n intent crear nota."""
        message = Message(
            text="Crear nota: comprar leche",
            user_id=1,
            tenant_id="default",
            session_id="test_session",
            timestamp=datetime.now(timezone.utc)
        )
        
        result = await router.process(message)
        
        assert result.intent == "create_note"
        assert result.agent_target == "NotesAgent"
    
    @pytest.mark.asyncio
    async def test_extract_entities_dates(self, router):
        """Test extracci√≥n de fechas."""
        message = Message(
            text="Evento ma√±ana a las 15:00",
            user_id=1,
            tenant_id="default",
            session_id="test_session",
            timestamp=datetime.now(timezone.utc)
        )
        
        result = await router.process(message)
        
        assert "date" in result.entities
        assert result.entities["date"] is not None
    
    @pytest.mark.asyncio
    async def test_extract_entities_locations(self, router):
        """Test extracci√≥n de lugares."""
        message = Message(
            text="Reuni√≥n en Madrid oficina central",
            user_id=1,
            tenant_id="default",
            session_id="test_session",
            timestamp=datetime.now(timezone.utc)
        )
        
        result = await router.process(message)
        
        assert "location" in result.entities
    
    @pytest.mark.asyncio
    async def test_route_to_correct_agent(self, router):
        """Test routing correcto."""
        test_cases = [
            ("crear evento", "EventsAgent"),
            ("nueva nota", "NotesAgent"),
            ("qu√© tengo ma√±ana", "AgendaAgent"),
            ("ayuda", "HelpAgent"),
            ("asdfghjkl", "FallbackAgent")
        ]
        
        for text, expected_agent in test_cases:
            message = Message(
                text=text,
                user_id=1,
                tenant_id="default",
                session_id="test_session",
                timestamp=datetime.now(timezone.utc)
            )
            
            result = await router.process(message)
            assert result.agent_target == expected_agent
    
    @pytest.mark.asyncio
    async def test_error_handling(self, router):
        """Test manejo de errores."""
        # Mensaje vac√≠o
        message = Message(
            text="",
            user_id=1,
            tenant_id="default",
            session_id="test_session",
            timestamp=datetime.now(timezone.utc)
        )
        
        result = await router.process(message)
        assert result.intent == "unknown"
        assert result.agent_target == "FallbackAgent"
    
    @pytest.mark.asyncio
    async def test_response_formatting(self, router):
        """Test formateo de respuesta."""
        message = Message(
            text="Crear evento",
            user_id=1,
            tenant_id="default",
            session_id="test_session",
            timestamp=datetime.now(timezone.utc)
        )
        
        result = await router.process(message)
        
        assert hasattr(result, "intent")
        assert hasattr(result, "entities")
        assert hasattr(result, "confidence")
        assert hasattr(result, "agent_target")
Cobertura esperada: ‚â•80%
Tiempo: 12h (8h c√≥digo + 4h tests)

üî• FASE 2: FSM Engine v2 (10h)
Ubicaci√≥n: src/theaia/core/fsm/engine_v2.py

Objetivo: Motor FSM con callbacks avanzados (pre/post/error).

C√≥digo Principal
python
"""
FSM Engine v2 - Motor de m√°quina de estados con callbacks
"""

from typing import Dict, Callable, Optional, List
from enum import Enum


class CallbackType(Enum):
    """Tipos de callbacks."""
    PRE_TRANSITION = "pre"
    POST_TRANSITION = "post"
    ON_ERROR = "error"


class FSMEngine:
    """
    Motor FSM con callbacks avanzados.
    
    Features:
    - Pre-callbacks: Validaciones antes de transici√≥n
    - Post-callbacks: Side effects despu√©s de transici√≥n
    - Error callbacks: Manejo de errores
    - Context merging inteligente
    """
    
    def __init__(self, conversation_repo):
        self.conversation_repo = conversation_repo
        self.callbacks: Dict[CallbackType, List[Callable]] = {
            CallbackType.PRE_TRANSITION: [],
            CallbackType.POST_TRANSITION: [],
            CallbackType.ON_ERROR: []
        }
    
    def register_callback(self, callback_type: CallbackType, callback: Callable):
        """Registra un callback."""
        self.callbacks[callback_type].append(callback)
    
    async def transition(
        self,
        conversation_id: int,
        tenant_id: str,
        new_state: str,
        context_update: Dict
    ) -> bool:
        """
        Ejecuta transici√≥n de estado con callbacks.
        
        Flow:
        1. Pre-callbacks (validaciones)
        2. Merge context
        3. Update state en DB
        4. Post-callbacks (side effects)
        5. Error callbacks (si falla)
        
        Args:
            conversation_id: ID conversaci√≥n
            tenant_id: Tenant ID
            new_state: Nuevo estado
            context_update: Actualizaciones de contexto
            
        Returns:
            True si transici√≥n exitosa
        """
        try:
            # 1. Pre-callbacks
            for callback in self.callbacks[CallbackType.PRE_TRANSITION]:
                valid = await callback(conversation_id, new_state, context_update)
                if not valid:
                    raise ValueError(f"Pre-callback failed: {callback.__name__}")
            
            # 2. Get current conversation
            conv = await self.conversation_repo.get_by_id(
                conversation_id,
                tenant_id
            )
            
            if not conv:
                raise ValueError(f"Conversation {conversation_id} not found")
            
            # 3. Merge context
            merged_context = self._merge_context(conv.context_data, context_update)
            
            # 4. Update state
            updated_conv = await self.conversation_repo.update_state(
                conversation_id=conversation_id,
                tenant_id=tenant_id,
                new_state=new_state,
                context=merged_context
            )
            
            # 5. Post-callbacks
            for callback in self.callbacks[CallbackType.POST_TRANSITION]:
                await callback(updated_conv)
            
            return True
            
        except Exception as e:
            # 6. Error callbacks
            for callback in self.callbacks[CallbackType.ON_ERROR]:
                await callback(conversation_id, e)
            
            raise
    
    def _merge_context(self, current: Dict, update: Dict) -> Dict:
        """
        Merge inteligente de contexto.
        
        Rules:
        - Nested dicts se fusionan recursivamente
        - Listas se reemplazan (no append)
        - None values se ignoran
        """
        if not current:
            return update
        
        merged = current.copy()
        
        for key, value in update.items():
            if value is None:
                continue
            
            if key in merged and isinstance(merged[key], dict) and isinstance(value, dict):
                # Recursive merge for nested dicts
                merged[key] = self._merge_context(merged[key], value)
            else:
                # Replace value
                merged[key] = value
        
        return merged
Tests (6 tests)
Ubicaci√≥n: src/theaia/tests/unit/core/fsm/test_engine_v2.py

python
class TestFSMEngine:
    """Tests para FSM Engine v2."""
    
    @pytest.mark.asyncio
    async def test_basic_transition(self, fsm_engine, sample_conversation):
        """Test transici√≥n b√°sica."""
        result = await fsm_engine.transition(
            conversation_id=sample_conversation.id,
            tenant_id="test_tenant",
            new_state="awaiting_confirmation",
            context_update={"action": "create_event"}
        )
        
        assert result is True
    
    @pytest.mark.asyncio
    async def test_pre_callback_validation(self, fsm_engine):
        """Test pre-callback con validaci√≥n."""
        validation_called = False
        
        async def validate_transition(conv_id, new_state, context):
            nonlocal validation_called
            validation_called = True
            return new_state == "valid_state"
        
        fsm_engine.register_callback(
            CallbackType.PRE_TRANSITION,
            validate_transition
        )
        
        # Valid transition
        result = await fsm_engine.transition(..., new_state="valid_state", ...)
        assert result is True
        assert validation_called
    
    @pytest.mark.asyncio
    async def test_post_callback_side_effects(self, fsm_engine):
        """Test post-callback con side effects."""
        side_effect_executed = False
        
        async def log_transition(conversation):
            nonlocal side_effect_executed
            side_effect_executed = True
            # Log to external service
        
        fsm_engine.register_callback(
            CallbackType.POST_TRANSITION,
            log_transition
        )
        
        await fsm_engine.transition(...)
        assert side_effect_executed
    
    @pytest.mark.asyncio
    async def test_error_callback(self, fsm_engine):
        """Test error callback."""
        error_handled = False
        
        async def handle_error(conv_id, error):
            nonlocal error_handled
            error_handled = True
            # Rollback, notify, etc.
        
        fsm_engine.register_callback(
            CallbackType.ON_ERROR,
            handle_error
        )
        
        # Force error
        with pytest.raises(ValueError):
            await fsm_engine.transition(..., new_state="invalid", ...)
        
        assert error_handled
    
    @pytest.mark.asyncio
    async def test_context_merge(self, fsm_engine):
        """Test merge de contexto."""
        current = {"a": 1, "b": {"c": 2}}
        update = {"b": {"d": 3}, "e": 4}
        
        merged = fsm_engine._merge_context(current, update)
        
        assert merged == {"a": 1, "b": {"c": 2, "d": 3}, "e": 4}
    
    @pytest.mark.asyncio
    async def test_invalid_transition_blocked(self, fsm_engine):
        """Test que transici√≥n inv√°lida se bloquea."""
        async def block_invalid(conv_id, new_state, context):
            return False  # Always block
        
        fsm_engine.register_callback(
            CallbackType.PRE_TRANSITION,
            block_invalid
        )
        
        with pytest.raises(ValueError):
            await fsm_engine.transition(...)
Cobertura esperada: ‚â•85%
Tiempo: 10h (7h c√≥digo + 3h tests)

üî• FASE 3: Intent Detector (spaCy) (12h)
Ubicaci√≥n: src/theaia/ml/intent_detector/detector_v2.py

Objetivo: Clasificador de intents b√°sico con spaCy (espa√±ol).

C√≥digo Principal
python
"""
Intent Detector v2 - Clasificador con spaCy
"""

import spacy
from typing import Tuple, List


class IntentDetector:
    """
    Clasificador de intents con spaCy.
    
    Intents soportados:
    - create_event
    - edit_event
    - delete_event
    - create_note
    - search_notes
    - query_agenda
    - get_reminders
    - help
    - unknown
    """
    
    # Patterns para cada intent
    INTENT_PATTERNS = {
        "create_event": [
            "crear evento",
            "nuevo evento",
            "agendar",
            "programar",
            "quiero crear",
            "a√±adir evento",
            "reuni√≥n"
        ],
        "create_note": [
            "crear nota",
            "nueva nota",
            "anotar",
            "recordar",
            "apuntar"
        ],
        "query_agenda": [
            "qu√© tengo",
            "mi agenda",
            "eventos de",
            "qu√© hay",
            "calendario"
        ],
        "help": [
            "ayuda",
            "help",
            "qu√© puedes hacer",
            "c√≥mo funciona"
        ]
    }
    
    def __init__(self):
        self.nlp = spacy.load("es_core_news_sm")
    
    async def detect(self, text: str) -> Tuple[str, float]:
        """
        Detecta intent del texto.
        
        Args:
            text: Texto usuario
            
        Returns:
            (intent, confidence)
        """
        doc = self.nlp(text)
        
        # Keyword matching (simple baseline)
        scores = {}
        
        for intent, patterns in self.INTENT_PATTERNS.items():
            score = 0
            for pattern in patterns:
                if pattern in text.lower():
                    score += 1
            
            if score > 0:
                scores[intent] = score / len(patterns)
        
        if not scores:
            return ("unknown", 0.0)
        
        # Get best intent
        best_intent = max(scores, key=scores.get)
        confidence = scores[best_intent]
        
        return (best_intent, confidence)
Tests (10 tests)
Ubicaci√≥n: src/theaia/tests/unit/ml/test_intent_detector.py

python
class TestIntentDetector:
    """Tests para Intent Detector."""
    
    @pytest.mark.asyncio
    async def test_detect_create_event(self, detector):
        """Test detecci√≥n crear evento."""
        test_cases = [
            "Quiero crear un evento",
            "Nuevo evento ma√±ana",
            "Agendar reuni√≥n",
            "Programar evento para el lunes"
        ]
        
        for text in test_cases:
            intent, confidence = await detector.detect(text)
            assert intent == "create_event"
            assert confidence > 0.5
    
    @pytest.mark.asyncio
    async def test_detect_create_note(self, detector):
        """Test detecci√≥n crear nota."""
        test_cases = [
            "Crear nota: comprar leche",
            "Nueva nota reuni√≥n",
            "Anotar esto"
        ]
        
        for text in test_cases:
            intent, confidence = await detector.detect(text)
            assert intent == "create_note"
    
    @pytest.mark.asyncio
    async def test_detect_query_agenda(self, detector):
        """Test detecci√≥n consultar agenda."""
        test_cases = [
            "Qu√© tengo ma√±ana",
            "Mi agenda de hoy",
            "Eventos del lunes"
        ]
        
        for text in test_cases:
            intent, confidence = await detector.detect(text)
            assert intent == "query_agenda"
    
    @pytest.mark.asyncio
    async def test_detect_help(self, detector):
        """Test detecci√≥n ayuda."""
        test_cases = [
            "Ayuda",
            "Help",
            "Qu√© puedes hacer",
            "C√≥mo funciona"
        ]
        
        for text in test_cases:
            intent, confidence = await detector.detect(text)
            assert intent == "help"
    
    @pytest.mark.asyncio
    async def test_confidence_score(self, detector):
        """Test score de confianza."""
        # High confidence
        intent, conf = await detector.detect("Crear evento ma√±ana")
        assert conf > 0.7
        
        # Low confidence
        intent, conf = await detector.detect("Quiz√°s algo")
        assert conf < 0.5 or intent == "unknown"
    
    @pytest.mark.asyncio
    async def test_unknown_intent(self, detector):
        """Test intent desconocido."""
        test_cases = [
            "asdfghjkl",
            "12345",
            "....."
        ]
        
        for text in test_cases:
            intent, confidence = await detector.detect(text)
            assert intent == "unknown"
            assert confidence == 0.0
    
    @pytest.mark.asyncio
    async def test_spanish_variations(self, detector):
        """Test variaciones en espa√±ol."""
        # Acentos
        assert (await detector.detect("programar reuni√≥n"))[0] == "create_event"
        
        # Sin√≥nimos
        assert (await detector.detect("agendar cita"))[0] == "create_event"
    
    @pytest.mark.asyncio
    async def test_edge_cases(self, detector):
        """Test casos edge."""
        # Texto vac√≠o
        intent, conf = await detector.detect("")
        assert intent == "unknown"
        
        # Solo espacios
        intent, conf = await detector.detect("   ")
        assert intent == "unknown"
    
    @pytest.mark.asyncio
    async def test_performance(self, detector):
        """Test performance."""
        import time
        
        start = time.time()
        for _ in range(100):
            await detector.detect("Crear evento")
        end = time.time()
        
        avg_time = (end - start) / 100
        assert avg_time < 0.1  # <100ms por detecci√≥n
Cobertura esperada: ‚â•85%
Tiempo: 12h (8h c√≥digo + 4h tests)